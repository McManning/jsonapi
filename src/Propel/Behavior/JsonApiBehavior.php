<?php

namespace McManning\JsonApi\Propel\Behavior;

use Propel\Generator\Model\Behavior;
use Propel\Generator\Builder\Om\ObjectBuilder;
use Propel\Generator\Builder\Om\QueryBuilder;
use Propel\Common\Pluralizer\StandardEnglishPluralizer;

/**
 * Propel behavior to add JSON:API conversion methods to an ActiveRecord
 *
 *  Usage:
 *
 *  <table name="MyFormModel">
 *      <behavior name="\McManning\JsonApi\Behavior\JsonApiBehavior">
 *
 *      </behavior>
 *  </table>
 *
 * TODO: Relationship iteration does not take in account whether the child class
 * contains the JsonApiBehavior or not. Only those that have the behavior should
 * be exposed as a related resource. Right now - the developer needs to do it
 * manually via exclude_relationships (which also isn't implemented...)
 */
class JsonApiBehavior extends Behavior
{
    protected $parameters = [
        // Column used for JSON:API IDs. Will automatically be excluded from `attributes`
        // If your ID column has an explicit `phpName`, this MUST match that.
        'id_column' => 'id',

        // Comma delimited columns to exclude from the `attributes` object.
        // Can be used as an alternative to writing your own
        // override for fromJsonApiAttributes/toJsonApiAttributes
        // for simple use cases
        'exclude_attributes' => '',

        // Comma delimited tables to exclude from autogenerated `relationships`
        'exclude_relationships' => '',

        // Comma delimited list of columns to include, ignoring prior
        // exclusion rules (such as automatic exclusions for columns that are FKs)
        'include_attributes' => ''
    ];

    /**
     * @var Propel\Generator\Builder\Om\ObjectBuilder
     */
    protected $builder;

    /**
     * @var Propel\Generator\Builder\Om\QueryBuilder
     */
    protected $queryBuilder;

    /**
     * @var string[]
     */
    protected $excludedAttributes;

    /**
     * @var string[]
     */
    protected $excludedRelationships;

    /**
     * @var array
     */
    protected $relationships;

    /**
     * Determine the value for the JSON:API `type` field
     *
     * @return string
     */
    protected function getType(): string
    {
        return $this->getTable()->getCamelCaseName();
    }

    /**
     * Return a list of columns that should not be presented as attributes
     *
     * This combines the user-defined blacklist as well as columns that
     * are FKs to other tables (typically converted to relationships).
     *
     * If there are any attributes listed in the whitelist, those will
     * be ignored from the exclusion list.
     *
     * @return string[]
     */
    protected function getExcludedAttributes(): array
    {
        // User defined exclusions list
        $exclusions = $this->getParameter('exclude_attributes');
        $exclusions = explode(',', $exclusions);
        $exclusions = array_map('trim', $exclusions);

        // User defined inclusions list
        $inclusions = $this->getParameter('include_attributes');
        $inclusions = explode(',', $inclusions);
        $inclusions = array_map('trim', $inclusions);

        // Automatically exclude the column used for JSON:API IDs
        $exclusions[] = trim($this->getParameter('id_column'));

        // Exclude any column labeled as an FK
        foreach ($this->getTable()->getColumns() as $column) {
            if ($column->isForeignKey()) {
                $exclusions[] = $column->getPhpName();
            }
        }

        // Drop any exclusions that are explicit inclusions
        $exclusions = array_diff($exclusions, $inclusions);

        return $exclusions;
    }

    /**
     * Return a list of relationships that should not be presented
     *
     * @return string[]
     */
    protected function getExcludedRelationships(): array
    {
        $relationships = $this->getParameter('exclude_relationships');
        $relationships = explode(',', $relationships);
        $relationships = array_map('trim', $relationships);

        // TODO: Exclude related tables that do not have JsonApiBehavior on them.
        // Is done in the builder, but should probably be here instead.

        return $relationships;
    }

    /**
     * Add behavior attributes to the model class
     *
     * @param ObjectBuilder $builder
     *
     * @return string the PHP code to be added to the builder
     */
    public function objectAttributes(ObjectBuilder $builder)
    {
        $excludeAttrs = $this->getExcludedAttributes();

        $excludeAttrsStr = '';
        if (!empty($excludeAttrs)) {
            $excludeAttrsStr = "'".implode("','", $excludeAttrs)."'";
        }

        $script = "
protected \$jsonApiExcludeAttributes = [".$excludeAttrsStr."];
";
        return $script;
    }

    /**
     * Add behavior methods to model class
     *
     * @param ObjectBuilder $builder
     *
     * @return string the PHP code to be added to the builder
     */
    public function objectMethods(ObjectBuilder $builder)
    {
        $this->builder = $builder;
        $this->setupRelationships();

        $script = $this->addResourceIdentifierMethods();
        $script .= $this->addAttributeMethods();
        $script .= $this->addRelationshipMethods();
        $script .= $this->addAccessControlMethods();
        $script .= $this->addLinksMethods();
        return $script;
    }

    /**
     * Add behavior methods to query class
     *
     * @param QueryBuilder $builder
     *
     * @return string the PHP code to be added to the builder
     */
    public function queryMethods(QueryBuilder $builder)
    {
        $this->queryBuilder = $builder;

        $script = $this->addRelationshipFilters();
        $script .= $this->addAccessControlFilters();
        return $script;
    }

    /**
     * Add methods for getting the id/type of a JSON:API resource
     *
     * @return string The code to be added to the model class
     */
    protected function addResourceIdentifierMethods(): string
    {
        return "
public function getJsonApiType(): string
{
    return '".$this->getType()."';
}

public function getJsonApiId(): string
{
    return \$this->get".$this->getParameter('id_column')."();
}
";
    }

    /**
     * Add methods to set/get values for JSON:API `attributes`
     *
     * @return string The code to be added to the model class
     */
    protected function addAttributeMethods(): string
    {
        return "
/**
 * Create the `attributes` entry of a JSON:API payload
 *
 * @param string[]|null \$fieldset  Sparse fieldset of attributes, by name, to include.
 *                                  A null value is treated at no sparsification.

 * @return void
 */
public function toJsonApiAttributes(array \$fieldset = null): array
{
    \$attributes = \$this->toArray(TableMap::TYPE_PHPNAME);

    // attributes UNION sparse fieldset keys
    if (\$fieldset !== null) {
        \$attributes = array_intersect_key(
            \$attributes,
            array_flip(\$fieldset)
        );
    }

    // attributes DIFF exclusions
    \$attributes = array_diff_key(
        \$attributes,
        array_flip(\$this->jsonApiExcludeAttributes)
    );

    return \$attributes;
}

/**
 * Read the `attributes` entry of a JSON:API payload
 *
 * @param string[] \$attributes Map of keys to values to read
 *
 * @return void
 */
public function fromJsonApiAttributes(array \$attributes)
{
    // attributes DIFF exclusions
    \$attributes = array_diff_key(
        \$attributes,
        array_flip(\$this->jsonApiExcludeAttributes)
    );

    return \$this->fromArray(\$attributes, TableMap::TYPE_PHPNAME);
}
";
    }

    /**
     * Populate `$this->relationships` with relationships to be exposed by the API.
     */
    protected function setupRelationships()
    {
        printf("\n-----\nModel: %s\n", $this->getTable()->getName());
        $relationships = [];

        foreach ($this->getTable()->getCrossFks() as $crossFk) {
            $incomingFk = $crossFk->getIncomingForeignKey();
            $outgoingFks = $crossFk->getCrossForeignKeys();

            printf(
                "----- CROSS -----\nTable: %s\nIncoming FK Name: %s\nIncoming Ref: %s\n",
                $crossFk->getTable()->getPhpName(),
                $this->builder->getFKPhpNameAffix($incomingFk, false),
                $this->builder->getRefFKPhpNameAffix($incomingFk, false)
            );

            foreach ($outgoingFks as $outgoingFk) {
                printf(
                    "Outgoing FK name: %s\nOutgoing FK Affix: %s\nOutgoing Ref: %s\n",
                    $outgoingFk->getName(),
                    $this->builder->getFKPhpNameAffix($outgoingFk, false),
                    $this->builder->getRefFKPhpNameAffix($outgoingFk, false)
                );
            }

            // Right now we assume there's only one outgoing FK.
            // Currently don't support more than that.
            if (count($outgoingFks) !== 1) {
                // TODO: Better error message...
                throw new \Exception('Only one outbound crossref FK is supported');
            }

            $outgoingFk = $outgoingFks[0];

            // Add a many-to-many relationship (pluralized on both ends)
            $relationships[] = [
                'name' => lcfirst($this->builder->getFKPhpNameAffix($outgoingFk, true)),
                'foreignTable' => $outgoingFk->getForeignTable(),
                'foreignType' => $outgoingFk->getForeignTable()->getPhpName(),
                'inverseRelationship' => lcfirst($this->builder->getFKPhpNameAffix($incomingFk, true)),
                'isToMany' => true
            ];
        }

        // Direct FK relationships - treat each as a to-one
        foreach ($this->getTable()->getForeignKeys() as $fk) {
            // foreign-key phpName - could differ from the related class' name.
            // But this defines the getters/setter/filters on this model.
            printf(
                "----- FK: %s-----\ntableName: %s\nphpName: %s\nrefPhpName: %s\nFKPhpNameAffix: %s\nRel Table Name: %s\n",
                $fk->getName(),
                $fk->getTable()->getPhpName(),
                $fk->getPhpName(),
                $fk->getRefPhpName(),
                lcfirst($this->builder->getFKPhpNameAffix($fk, false)),
                $fk->getForeignTable()->getPhpName()
            );

            // one-to-one mapping
            if ($fk->isMatchedByInverseFK()) {
                $inverse = $fk->getInverseFk();
                printf(
                    "Inverse Name: %s\nInverse PhpName: %s\n",
                    $inverse->getName(),
                    $inverse->getPhpName()
                );
            }

            // We know this FK is to-one to a parent, but we need
            // to identify whether that parent is to-one to this FK
            // for pluralization of the inverse relationship.
            $isOneToOne = $fk->isMatchedByInverseFK();

            // Construct something that makes sense...
            $relationships[] = [
                'name' => lcfirst($this->builder->getFKPhpNameAffix($fk, false)),
                'foreignTable' => $fk->getForeignTable(),
                'foreignType' => $fk->getForeignTable()->getPhpName(),
                'inverseRelationship' => lcfirst($this->builder->getRefFKPhpNameAffix($fk, !$isOneToOne)),
                'isToMany' => false
            ];
        }

        // Track referrer FKs to this table as relationships
        $referrers = $this->getTable()->getReferrers();
        foreach ($referrers as $refFk) {
            // Skip cross-reference tables - handled earlier via getCrossFks
            if ($refFk->getTable()->isCrossRef()) {
                continue;
            }

            printf(
                "----- REF FK: %s-----\ntableName: %s\nphpName: %s\nrefPhpName: %s\nFKPhpNameAffix: %s\nRel Table Name: %s\nMatched By Inverse FK: %s\n",
                $refFk->getName(),
                $refFk->getTable()->getPhpName(),
                $refFk->getPhpName(),
                $refFk->getRefPhpName(),
                lcfirst($this->builder->getFKPhpNameAffix($refFk, false)),
                $refFk->getForeignTable()->getPhpName(),
                $refFk->isLocalPrimaryKey()
            );

            $isOneToOne = $refFk->isLocalPrimaryKey();

            $relationships[] = [
                'name' => lcfirst($this->builder->getRefFKPhpNameAffix($refFk, !$isOneToOne)),
                'foreignTable' => $refFk->getTable(),
                'foreignType' => $refFk->getTable()->getPhpName(),
                'inverseRelationship' => lcfirst($this->builder->getFKPhpNameAffix($refFk, false)),
                'isToMany' => !$isOneToOne
            ];
        }

        // Filter out relationships that are for models not exposed to
        // the API or explicitly excluded by our settings
        $exclusions = $this->getExcludedRelationships();
        $filteredRelationships = [];

        foreach ($relationships as $rel) {
            if (!in_array($rel['foreignTable']->getName(), $exclusions) &&
                $rel['foreignTable']->hasBehavior($this->getId())
            ) {
                $filteredRelationships[] = $rel;
            }
        }

        $this->relationships = $filteredRelationships;
    }

    /**
     * Add methods to get descriptors for for JSON:API `relationships`
     *
     * @return string The code to be added to the model class
     */
    protected function addRelationshipMethods(): string
    {
        $script = '';
        foreach ($this->relationships as $rel) {
            $name = $rel['name'];
            $foreignType = $rel['foreignType'];
            $inverse = $rel['inverseRelationship'];
            $toMany = $rel['isToMany'] ? 'true' : 'false';

            $script .= "
    \${$name} = new \\McManning\\JsonApi\\Relationship('$name');
    \${$name}->setModelName(Child{$foreignType}::class);
    \${$name}->setInverseRelationship('$inverse');
    \${$name}->setToMany($toMany);
    \$relationships->add(\${$name});
";
        }

        return "
/**
 * TODO: Docblock
 *
 * @return \\McManning\\JsonApi\\RelationshipCollection
 */
public function getRelationships(): \\McManning\\JsonApi\\RelationshipCollection
{
    \$relationships = new \\McManning\\JsonApi\\RelationshipCollection();
    {$script}
    return \$relationships;
}
";
    }

    /**
     * @return string The code to be added to the model class
     */
    protected function addAccessControlMethods(): string
    {
        return "
/**
 * TODO: Docblock
 *
 * @param \\McManning\\JsonApi\\AuthorizationRequest \$request The authorized request to test against
 *
 * @throws \\McManning\\JsonApi\\Exception\\AuthorizationRequestException if the request is not authorized
 */
public function testAuthorizationRequest(\\McManning\\JsonApi\\AuthorizationRequest \$request)
{

}
";
    }
    /**
     * @return string The code to be added to the model class
     */
    protected function addLinksMethods(): string
    {
        return "
/**
 * TODO: Docblock
 *
 * @return array Hashmap of link names to URIs
 */
public function getJsonApiLinks(): array
{
    return [];
}
";
    }

    /**
     * Add behavior attributes to query class
     *
     * @param QueryBuilder $builder
     *
     * @return string the PHP code to be added to the builder
     */
    public function queryAttributes(QueryBuilder $builder)
    {
        $script = "
/**
 * @var \\McManning\\JsonApi\\AuthorizationRequest
 */
protected \$jsonApiAuthRequest;
";
    }

    /**
     * Add methods to support filter[relationshipName]=ID queries.
     *
     * @return string The code to be added to the model class
     */
    protected function addRelationshipFilters(): string
    {
        $script = '';
        foreach ($this->relationships as $rel) {
            $name = $rel['name'];
            $foreignType = $rel['foreignType'];
            $inverse = $rel['inverseRelationship'];
            $toMany = $rel['isToMany'] ? 'true' : 'false';

            $script .= "
/**
 * TODO: Docblock
 *
 * @return self The current query, for fluid interface
 */
public function filterBy{$name}Relationship(\$id)
{
    return \$this
        ->use{$foreignType}Query()
        ->filterById(\$id)
        ->endUse();
}
";
        }

        return $script;
    }

    public function addAccessControlFilters(): string
    {
        $script = "
/**
 * TODO: Docblock!
 *
 * @return self The current object (for fluent API support)
 */
public function filterByAuthorizationRequest(\\McManning\\JsonApi\\AuthorizationRequest \$request): self
{
    \$this->jsonApiAuthRequest = \$request;
    return \$this;
}

/**
 * TODO: Docblock
 *
 * @param string[] \$expectedIds List of resource IDs that MUST come back,
 *                              otherwise the request is considered an authorization
 *                              failure (as certain expected results did not pass
 *                              the pre-query authorization filters). If not supplied,
 *                              IDs will not be checked and only post-query authorization
 *                              tests will be used to determine failures for each resource
 *
 * @throws \\McManning\\JsonApi\\Exception\\AuthorizationRequestException   if there is a mismatch between
 *                                                                      expected IDs and find results
 */
public function findAuthorized(array \$expectedIds = null): iterable
{
    if (!\$this->jsonApiAuthRequest) {
        throw new \RuntimeException('Used findAuthorized without filterByAuthorizationRequest');
    }

    \$results = \$this->find();

    foreach (\$results as \$result) {
        // Execute post-query auth per returned instance
        \$result->testAuthorizationRequest(\$this->jsonApiAuthRequest);

        if (\$expectedIds !== null) {
            \$idx = array_search(\$result->getJsonApiId(), \$expectedIds);
            if (\$idx !== false) {
                unset(\$expectedIds[\$idx]);
            }
        }
    }

    if (\$expectedIds !== null && !empty(\$expectedIds)) {
        throw new \\McManning\\JsonApi\\Exception\\AuthorizationRequestException(
            \$this->jsonApiAuthRequest,
            sprintf(
                'Unauthorized to access IDs `%s`',
                implode('`, `', \$expectedIds)
            )
        );
    }

    // TODO: Deal with extra results
    return \$results;
}

/**
 * TODO: Docblock
 *
 * @param string \$expectedId   Resource ID that MUST be returned. Otherwise an
 *                              AuthorizationRequestException is thrown.
 *
 * @throws \\McManning\\JsonApi\\Exception\\AuthorizationRequestException   if there is a mismatch between
 *                                                                      the expected ID and find results
 * @return ActiveRecordInterface
 */
public function findOneAuthorized(string \$expectedId)
{
    if (!\$this->jsonApiAuthRequest) {
        throw new \RuntimeException('Used findOneAuthorized without filterByAuthorizationRequest');
    }

    \$result = \$this->findOne();
    if (\$result === null || \$result->getJsonApiId() !== \$expectedId) {
        throw new \\McManning\\JsonApi\\Exception\\AuthorizationRequestException(
            \$this->jsonApiAuthRequest,
            sprintf(
                'Unauthorized to access ID `%s`',
                \$expectedId
            )
        );
    }

    \$result->testAuthorizationRequest(\$this->jsonApiAuthRequest);
    return \$result;
}
";
        // TODO: filterByJsonApiId? Proxies to the ID column filter.

        return $script;
    }
}
